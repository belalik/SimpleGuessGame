using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
/*
 * Ένα απλό πρόγραμμα - παιχνίδι, που ζητάει από τον χρήστη να μαντέψει έναν κρυφό αριθμό από το 1 μέχρι το 100. 
 * 
 * 
 * Ζητάω από τον χρήστη να μαντέψει τον αριθμό. 
 * 
 * Ο χρήστης δίνει έναν αριθμό. 
 * 
 * Όσο ο αριθμός που μου δίνει είναι λάθος, 
 *  
 *      Αν ο μυστικός αριθμός είναι μικρότερος, του λέω να δοκιμάσει μικρότερο αριθμό
 *      
 *      αν ο μυστικός αριθμός είναι μεγαλύτερος, του λέω να δοκιμάσει μεγαλύτερο αριθμό. 
 *      
 * Όταν μου δώσει τον σωστό αριθμό, τυπώνω κατάλληλο μήνυμα και γράφω πόσες προσπάθειες χρειάστηκε. 
 * 
 * 
 * 
 * Το 'παιχνίδι' έχει φτιαχτεί επίτηδες με τρόπο που να φτιάχνει διαφορετικές κλάσεις, έτσι ώστε να είναι 
 * ένα παράδειγμα για την κατασκευή αντικειμένων (objects) και μεθόδων (methods) διαφορετικών κλάσεων. 
 * 
 */
namespace SimpleGuessGame
{
    class Program
    {
        // Η main μέθοδος - η εκτέλεση του προγράμματος ξεκινάει από εδώ. 
        static void Main(string[] args)
        {

            // Φτιάχνω το αντικείμενο secret που είναι instance της κλάσης SecretNumber. 
            // Εκεί ουσιαστικά δημιουργώ και "φυλάω" τον μυστικό -τυχαίο- αριθμό από 1 μέχρι 100. 
            SecretNumber secret = new SecretNumber();

            /*
            Φτιάχνω το αντικείμενο refe που είναι instance της κλάσης Referee. 
            
            Θα το ονόμαζα 'ref' αλλά δεν μπορώ, γιατί το 'ref' είναι reserved word (δεσμευμένη λέξη) της C# ... 
            Παρατηρείστε πως περνάω ένα ΑΝΤΙΚΕΙΜΕΝΟ (το secret) σαν παράμετρο στον constructor του Referee. 
            Αυτό δεν το έχουμε δει ακόμα, αλλά είναι απλό - μια μέθοδος (στον προκειμένη περίπτωση ο constructor του Referee) 
            μπορεί να δέχεται (ή και να επιστρέφει) εκτός από απλά types, πχ int, string κλπ, και ένα ολόκληρο αντικείμενο. 
            
            Στην δική μου υλοποίηση, σκέφτηκα πως με βολέυει να το σχεδιάσω έτσι ώστε ο Referee να 'έχει' ως χαρακτηριστικό/ιδιότητα 
            ένα αντικείμενο της κλάσης Secret. 
            */
            Referee refe = new Referee(secret);

            Console.WriteLine("Welcome to the Guessing game");

            Console.WriteLine("You have to guess the magic number - it is between 1 and 100 ");

            // Φτιάχνω τις μεταβλητές number και answer, χωρίς να τους δίνω τιμές.
            // σημείωση: στην C# μια int μεταβλητή που δεν έχω ορίσει τιμή, παίρνει την τιμή 0 από default. 
            int number;
            int answer;

            /*
             *  Υλοποίηση ενός do-while loop.  Προσέξτε πως το do-while έχει μια βασική διαφορά με το while-loop:
             *  
             *  Ο κώδικας που είναι μέσα στο do, ΄δηλαδή μέσα στο do { ... }, ΘΑ ΤΡΕΞΕΙ ΟΠΩΣΔΗΠΟΤΕ 
             *  ΜΙΑ ΦΟΡΑ.  ΜΕΤΑ ΘΑ ΕΠΑΝΑΛΑΜΒΑΝΕΤΑΙ ΟΣΟ ΙΣΧΥΕΙ Η ΣΥΝΘΗΚΗ ΤΟΥ WHILE.  Θα τρέξει πάντως μια φορά οπωσδήποτε.  
             *  Αυτό είναι βασική διαφορά του do { ... } (while) με το σκέτο while, στο οποίο ανάλογα την συνθήκη, 
             *  ο κώδικας μπορεί να μην εκτελεστεί ούτε μια φορά. 
             *  
             *  Μπορείτε σαν άσκηση να αλλάξετε αυτόν τον κώδικα, και να το υλοποιήσετε με ένα while-loop αντί για do-while. 
             */
            do
            {
                Console.Write("Give me your guess: ");

                // διαβάζω τον αριθμό που μου δίνει ο χρήστης, και τον αποθηκεύω στην μεταβλητή number που είχα δηλώσει νωρίτερα.
                number = Convert.ToInt16(Console.ReadLine());

                /*  Χρησιμοποιώ την μέθοδο Check της κλάσης Referee για να ελέγξω τον αριθμό number. 
                    
                    Η μέθοδος Check μου γυρνάει ένα int που το αποθηκεύω στην μεταβλητή answer.                 
                */
                answer = refe.Check(number);


                // Αν ο αριθμός που μου γύρισε η Check είναι μεγαλύτερος από 0 - ξέρω πως ο μυστικός
                // αριθμός είναι μικρότερος από αυτόν που έδωσε ο χρήστης, οπότε τυπώνω κατάλληλο μήνυμα
                // (του λέω να επιλέξει μικρότερο αριθμό). 
                if (answer > 0)
                {
                    Console.WriteLine("Pick a LOWER number !!!");
                }

                // Αν ο αριθμός που μου γύρισε η Check είναι μικρότερος από 0 - ξέρω πως ο μυστικός
                // αριθμός είναι μεγαλύτερος από αυτόν που έδωσε ο χρήστης, οπότε τυπώνω κατάλληλο μήνυμα
                // (του λέω να επιλέξει μεγαλύτερο αριθμό). 
                else if (answer < 0)
                {
                    Console.WriteLine("Pick a BIGGER number !!!");
                }

            } // κλείνει το do. 


            /*  Το while που ελέγχει την επανάληψη του κώδικα που βρίσκεται μέσα στο do { ... }

                Στη συγκεκριμένη περίπτωση, θέλω η επανάληψη να γίνεται για πάντα, 
                ΜΕΧΡΙ το answer (δηλαδή η απάντηση που δίνει η μέθοδος Check) να είναι ίση με μηδέν. 
                
                Όταν το answer γίνει μηδέν (όταν δηλαδή η Check μου απαντήσει με την τιμή 0) ξέρω 
                πως ο χρήστης βρήκε τον σωστό αριθμό. 
            */
            while (answer != 0);


            // Όταν βγω από το while, ξέρω πως έχει βρει την σωστή απάντηση, οπότε απλώς τυπώνω κατάλληλα μηνύματα. 
            // Όντως το number που μου έδωσε, είναι ίδιο με το secret.TheSecretNumber (get μέθοδος της κλάσης SecretNumber). 
            Console.WriteLine("Well done, you found the secret number: " + number + " ... indeed it is: " + secret.TheSecretNumber);

            Console.WriteLine("It took you: " + refe.HowManyTries() + " tries.");


        }
    }



    // Απλή κλάση που δημιουργεί έναν τυχαίο αριθμό. 
    class SecretNumber
    {

        public SecretNumber()
        {
            /*
             *  Χρησιμοποιώ την μέθοδο Next της κλάσης Random του namespace System.  
             *  Παίρνει παραμέτρους που δείχνουν το εύρος, δηλαδή το 'από' και 'μέχρι'
             *  και μου γυρνάει έναν τυχαίο αριθμό μέσα σε αυτό το εύρος. 
             *  
             *  Είναι μια από τις πάρα πολλές χρήσιμες έτοιμες μεθόδους που προσφέρει η C# μέσω των βιβλιοθηκών της. 
             *  Άλλη μια που χρησιμοποιούμε πολύ συχνά είναι η WriteLine και η ReadLine, που ακόμα και αν 
             *  δεν το έχουμε συνειδητοποιήσει, είναι μέθοδοι της κλάσης Console, που και αυτή ανήκει στο namespace System. 
             * 
             *  Παρατηρείστε πως ουσιαστικά στον constructor εδώ, χρησιμοποιώ την set μέθοδο 
             *  της ιδιότητας TheSecretNumber. 
            
             *  Έτσι, κάθε φορά που δημιουργώ ένα αντικείμενο της κλάσης SecretNumber, με 
             *  την υλοποίησή του θα έχει αυτόματα παραχθεί και ένας τυχαίος αριθμός 
             *  από το 1 μέχρι το 100 και θα είναι διαθέσιμος μέσω της get μεθόδου της ιδιότητας (property) TheSecretNumber.
             */
            TheSecretNumber = new Random().Next(1, 100);
        }

        public int TheSecretNumber { get; set; }



    }

    // Κλάση Referee - θα χρησιμοποιείται για να υλοποιήσει έναν 'διαιτητή' που αποφασίζει 
    // για την εξέλιξη του παιχνιδιού μέσω κατάλληλων μεθόδων.
    class Referee
    {


        // Μεταβλητή που κρατάει το πόσες προσπάθειες χρειάστηκε ο παίκτης μέχρι να βρει τον αριθμό. 
        private int numberOfTries;

        // μεταβλητή που χρησιμοποιείται στην μέθοδο Check (είναι το αποτέλεσμα που θα γυρίσω στο τέλος)
        int result;

        /*
         *  Constructor για την κλάση Referee.  Παίρνει σαν παράμετρο ένα αντικείμενο της κλάσης SecretNumber. 
         */
        public Referee(SecretNumber theNumber)
        {
            MySecretNumber = theNumber;

            // αρχικοποιώ το numberOfTries με την τιμή 0.  Δεν είναι απαραίτητο, από default θα έπαιρνε το 0. 
            // Το κάνω για λόγους ευκολίας - κάποιος που διαβάζει τον κώδικα το "περιμένει" και του εξηγεί καλύτερα την σκέψη μου. 
            numberOfTries = 0;
        }


        // Απλή μέθοδος που επιστρέφει την τιμή της μεταβλητής numberOfTries.  Θα μπορούσα να έχω και 
        // ένα property NumberOfTries και να χρησιμοποιώ την 'get' μέθοδό του.  Το έκανα με διαφορετικό 
        // τρόπο για να δείξω οτι γίνεται και έτσι. 
        public int HowManyTries()
        {
            return numberOfTries;
        }

        // Ιδιότητα (χαρακτηριστικό) της κλάσης ένα αντικείμενο SecretNumber. Όπως είπαμε και στην αρχή, 
        // μπορούν οι κλάσεις να έχουν αντικείμενα άλλων κλάσεων σαν ιδιότητες και όχι μόνο απλούς τύπους int, string κλπ. 
        // Εδώ έχω την ιδιότητα MySecretNumber που έχει κανονικά get και set.  Η set χρησιμοποιείται από τον 
        // constructor πιο πάνω, για να ορίσει το MySecretNumber να είναι το αντικείμενο theNumber που περάστηκε σαν παράμετρος στον Constructor. 
        public SecretNumber MySecretNumber { get; set; }


        /*
         *  Μέθοδος που τσεκάρει αν ο αριθμός που έδωσε ο χρήστης (περνάει σαν παράμετρος με την μεταβλητή number) 
         *  είναι ίσο, μικρότερο ή μεγαλύτερο από τον μυστικό αριθμό (τον οποίο πάίρνω χρησιμοποιώντας το αντικείμενο 
         *  MySecretNumber και την get μέθοδο της ιδιότητας TheSecretNumber που έχει η κλάση SecretNumber). 
         *  
         *  Επιστρέφει ένα int - και συγκεκριμένα θα είναι 0, 1 ή -1. 
         */
        public int Check(int number)
        {

            // κάθε φορά που τρέχει η Check, πρέπει να αυξήσω το numberOfTries κατά ένα. 
            numberOfTries++;

            // Αν οι αριθμοί είναι ίσοι, σημαίνει πως ο χρήστης μάντεψε τον μυστικό αριθμό.  Δώσε στο result τιμή: 0. 
            if (number == MySecretNumber.TheSecretNumber)
            {
                result = 0;
            }

            // Αλλιώς εαν ο αριθμός που έδωσε ο χρήστης είναι μεγαλύτερος, επιστρέφω την τιμή: 1.  Δώσε στο result την τιμή: 1.
            else if (number > MySecretNumber.TheSecretNumber)
            {
                result = 1;
            }

            // Αλλιώς (αν δηλαδή ο αριθμός που έδωσε ο χρήστης είναι μικρότερος), επιστρέφω την τιμή: -1.  Δώσε στο result την τιμή -1. 
            else
            {
                result = -1;
            }

            // Η μέθοδος επιστρέφει το result. 
            return result;
        }
    }
}
